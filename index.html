<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Matemática IV</h2>
				</section>
				<section>
					<h3>Aplicaciones de los contenidos de la materia</h3>
				</section>
				<section>
					<section>
						<h3>Números Complejos</h3>
					</section>
					<section>
						<h4>Representación de objetos en un plano bidimensional</h4>
						<ul class="fragment">
							<li>
								Números complejos como herramientas
							</li>
							<li class="fragment">
								Casos específicos
							</li>
						</ul>
					</section>
					<section>
						<h4>Análisis de frecuencias</h4>
						<ul class="fragment">
							<li>
								Generación de terrenos
							</li>
							<li class="fragment">
								Análisis de sonido
							</li>
							<li class="fragment">
								...
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h3>Conceptos Necesarios</h3>
						<h6>Repaso</h6>
					</section>
					<section>
						<p>Un número complejo es un número de la forma $ a + bi $ donde:</p>
						<ul>
							<li class="fragment">
								<p>$ a, b \in \mathbb{R} $</p>
							</li>
							<li class="fragment">
								<p>$ i $ es la solución a la ecuación $ x^2 = -1 $</p>
							</li>
						</ul>
					</section>
					<section>
						<p>En el número $a + bi$, $a$ es la parte real y $b$ es la parte imaginaria.</p>
					</section>
					<section>
						<p>
							El sistema numérico complejo se puede definir como la extensión algebraica de los números reales
							ordinarios mediante un número imaginario $i$. Esto significa que los números complejos
							se pueden sumar, restar y multiplicar como polinomios en la variable $i$, con la regla
							$i^2 = -1$ impuesta.
						</p>
					</section>
					<section>
						<p>
							Además, los números complejos también se pueden dividir por números complejos
							distintos de cero.
						</p>
					</section>
					<section>
						<p>
							Geometricamente, los números complejos extienden el concepto
							de linea numérica unidimensional a <strong>plano complejo bidimensional</strong>.
						</p>
					</section>
					<section>
						<p>En el plano complejo, el número $a + bi$ puede representarse como el punto $(a, b)$ de la siguiente forma:</p>
						<a href="#" class="navigate-down">
							<img
								alt="Down arrow"
								data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png"
								style="border: none;"
								width="178"
								height="238"
							>
						</a>
					</section>
					<section>
						<h3>Plano Complejo</h3>
						<img src="images/complex_plane.jpg" alt="">
					</section>
				</section>
				<section>
					<section>
						<h2>Representación de objetos</h2>
						<h6>Traslaciones y Rotaciones</h6>
					</section>
					<section>
						<p>
							Los números complejos forman un <strong><em>Cuerpo</em></strong>,
							por lo que dos números complejos $a$ y $b$ pueden sumarse y
							multiplicarse.
						</p>
					</section>
					<section>
						Geometricamente hablando, los números complejos se suman como
						<em>vectores euclideos</em>. La multiplicación de dos números complejos
						se puede expresar más fácilmente en coordenadas polares:
					</section>
					<section>
						<p>Sean $a = x_1 + y_{1}i, b = x_2 + y_{2}i \in \mathbb{C}$ tales que:</p>

						<ul>
							<li>|$a$| $= r_a, arg(a) = \theta_a$</li>
							<li>|$b$| $= r_b, arg(b) = \theta_b$</li>
						</ul>

						<p>
							Definimos el producto complejo de la siguiente forma:
						</p>

						<p>
							\[\begin{aligned}
								ab &amp;= r_{a}r_{b} \textbf{e}^{i(\theta_a + \theta_b)} \\
									 &amp;= {r_{a}r_{b}}_{(\theta_a + \theta_b)}
							\end{aligned}\]
						</p>
					</section>
					<section>
						Luego, si $r_b = 1$ entonces la multiplicación funciona como rotación.
					</section>
				</section>
				<section>
					<section>
						<h2>Ejemplo Específico</h2>
					</section>
					<section>
						<p>
							Queremos representar la posición de un objeto cuyo
							movimiento se muestra de la siguiente forma:
						</p>

						<img width="500px" src="images/easy_harmonic_oscillator.gif" alt="">
					</section>
					<section>
						<p>
							Podemos ver como se comporta el movimiento en el eje x en la siguiente
							imagen:
						</p>

						<img src="images/complex_plane_sin.gif" alt="">
					</section>
					<section>
						<p>
							Además, observamos en el siguiente gráfico como es el
							comportamiento del mismo en función de funciones trigonométricas
							conocidas.
						</p>

						<img src="images/complex_plane_cos_sin.gif" alt="">
					</section>
					<section>
						A partir de la animación anterior podemos observar los siguientes
						items:
					</section>
					<section>
						En un caso ideal, la posición en el eje real se comporta como
						una función <em>coseno</em>, y sabemos de Matemática II que la razón de cambio
						de la función está dada por la función <em>seno</em>.
					</section>
					<section>
						Pero, <strong>¿a qué llamamos caso ideal?</strong>
					</section>
					<section>
						El mundo físico no es ideal, y sabemos que la posición de un objeto
						cambia a medida que transcurre el tiempo.
					</section>
					<section>
						Necesitamos poder definir la posición del objeto en función del tiempo.
					</section>
					<section>
						<p>La misma se comporta de la siguiente forma:</p>
						<img width="526px" src="images/damped_oscillation.jpg" alt="">
					</section>
					<section>
						Para esto buscamos la forma de atenuar la función coseno que ya tenemos
						e indicar cual será la amplitud inicial de la misma.
					</section>
					<section>
						<h3>Amplitud</h3>
						<p>
							Para definir la amplitud inicial de la función <em>coseno</em> simplemente
							multiplicamos la posición del objeto por un número que
							signifique la amplitud inicial del resorte, $A$.
						</p>
					</section>
					<section>
						<h3>Periodo</h3>
						<p>
							Sabemos que la función $cos$ recibe la variable $t$ como argumento
							en cada iteración. Luego, podemos evaluar como afectaría
							a la posición del objeto multiplicar ese tiempo $t$ por
							un valor real $\omega$.
						</p>
					</section>
					<section>
						<h3>Fase</h3>
						<p>
							Finalmente, determinamos cuan corrido está el dibujo de la función
							<em>coseno</em> en base a la fase $\phi$.
						</p>
					</section>
					<section>
						Se puede ver como los conceptos mencionados anteriormente
						afectan a la gráfica de una función $sin$ en el siguiente
						<a href="https://www.geogebra.org/m/KfUX66de" target="_blank">
							enlace
						</a>.
					</section>
					<section>
						<p>
							Juntando todas las definiciones planteadas anteriormente,
							resumimos la posición del objeto en función del tiempo de la siguiente
							forma:
						</p>
						<ul>
							<li>$x(t) = Acos(\omega t + \phi)$</li>
							<li>$y(t) = Asin(\omega t + \phi)$</li>
						</ul>
					</section>
					<section>
						<p>
							Particularmente, si tomamos la amplitud $A$ como la distancia de la caja al centro del plano
							es decir, el módulo de la posición, y sea $\theta = \omega t + \phi$,
							el argumento de la posición a lo largo del tiempo, tenemos la
							posición en forma trinométrica,
						</p>

						<p>
							\[
								r(t) = A (cos(\theta) + i sin(\theta))
							\]
						</p>
					</section>
					<section>
						<p>
							Sabemos a su vez que, si derivamos $x(t)$ ó $y(t)$ respecto de $t$,
							obtenemos la velocidad a la que se mueve el objeto,
							quedando la siguiente función de velocidad para cada uno respectivamente:
						</p>
						<ul>
							<li>$v_{x}(t) = -A \omega sin(\omega t + \phi)$</li>
							<li>$v_{y}(t) = A \omega cos(\omega t + \phi)$</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h3>Análisis de Frecuencias</h3>
					</section>
					<section>
						Respecto de este area de aplicaciones vamos a enfocarnos en dos
						casos de aplicación.
					</section>
					<section>
						A diferencia del ejemplo anterior, no disponemos de los conceptos
						necesarios para terminar de comprender los fundamentos detras de estos
						temas...
					</section>
					<section>
						...pero se espera ir profundizando a medida que transcurre la materia.
					</section>
					<section>
						El código de los ejemplos que se plantean a continuación se puede
						encontrar en el siguiente
						<a href="https://github.com/ulises-jeremias/frequency-analysis-with-FFT" target="_blank">
							repositorio
						</a>
						de github.
					</section>
					<section>
						En dicho repositorio se puede encontrar una breve descripción de cada uno
						de los proyectos, objetivos de los mismos y formas de utilización.
					</section>
				</section>
				<section>
					<section>
						<h3>Generación de Terrenos</h3>
					</section>
					<section>
						Como ejemplo tenemos la generación procedural de un terreno tridimensional
						utilizando <strong>Perlin Noise</strong> y la función
						<a href="https://processing.org/reference/beginShape_.html" target="_blank">
							<strong>
								beginShape
							</strong>
						</a>
						de Processing.
					</section>
				</section>
				<section>
					<section>
						<h3>Análisis de audios</h3>
					</section>
					<section>
						En el repositorio de Análisis de Frecuencias se puede ver un proyecto
						en python, el cual permite observar como se representa graficamente
						una onda de audio recibida por micrófono y se compara su gráfica
						con el espectro de la misma.
					</section>
					<section>
						Se utiliza <strong>scipy.fftpack</strong> para computar la <em>FFT</em>
						y mostrar el espectro del audio en tiempo real utilizando algunas
						herramientas del lenguaje <em>python</em>.
					</section>
					<section>
						Además se muestra un curioso
						<a href="https://github.com/CFSworks/wavebird-reversing/blob/master/03_complex_signals_and_fourier/synthesize.py" target="_blank">
							ejemplo
						</a>
						de como se utilizan	señales complejas y la Transformada de Fourier para generar
						un archivo de audio a partir de una lista de números complejos
						representados en forma polar.
					</section>
				</section>
				<section>
					<section>
						<h2>Links de interes</h2>
						<ul>
							<li>
								<a href="https://github.com/ulises-jeremias/matematica-iv" target="_blank">
									Repositorio de las clases
								</a>
							</li>
							<li>
								<a href="https://github.com/ulises-jeremias/frequency-analysis-with-FFT" target="_blank">
									Frecuency Analysis with FFT
								</a>
							</li>
							<li>
								<a href="https://github.com/CFSworks/wavebird-reversing" target="_blank">
									Reverse-engineering Nintendo's WaveBird wireless controller
								</a>
							</li>
						</ul>
					</section>
				</section>
				<section>
					<h2>Segunda Clase de Aplicaciones</h2>
				</section>
				<section>
					<section>
						<h3>Machine Learning</h3>
					</section>
					<section>
						Subcampo de las ciencias de la computación y una rama de la inteligencia artificial, 
						cuyo objetivo es desarrollar técnicas que permitan que las computadoras aprendan.
					</section>
					<section>
						De forma más concreta, se trata de crear programas capaces de generalizar
						comportamientos a partir de una información suministrada en forma de ejemplos.
					</section>
					<section>
						El aprendizaje automático puede ser visto como un intento de automatizar
						algunas partes del método científico mediante métodos matemáticos.
					</section>
					<section>
						Es una de las ramas que, junto a la estadística, minería de datos y analítica predictíva, da lugar
						a la Ciencia de Datos.
					</section>
				</section>
				<section>
					<section>
						<h3>Matemática para Machine Learning</h3>
					</section>
					<section>
						Para ver como afectan las distintas ramas de la Matemática vamos
						a analizar el siguiente gráfico.
					</section>
					<section>
						<h2>INSERTE IMAGEN PILLA AQUÍ!!!</h2>
					</section>
					<section>
						En este gráfico se expone el núcleo de todo lo que da sentido al Machine Learning.
					</section>
					<section>
						<ul>
							<li>
								<strong>Estadística</strong> es el núcleo de todo esto.
							</li>
							<li class="fragment">
								<strong>Cálculo</strong> nos dice como aprende y se optimizan nuestros
								modelos.
							</li>
							<li class="fragment">
								<strong>Álgebra Lineal</strong> permite la ejecución de estos algoritmos
								en conjuntos de datos masivos.
							</li>
							<li class="fragment">
								<strong>Probabilidad</strong> ayuda a predecir la probabilidad de que un evento ocurra.
							</li>
						</ul>
					</section>
					<section>
						Para entender como entran en juego las ramas mensionadas anteriormente veamos
						un ejemplo simple a continuación.
					</section>
					<section>
						<h5><a href="https://www.youtube.com/watch?v=8onB7rPG4Pk" target="_blank" rel="noopener noreferrer">Ejemplo</a></h5>
						<blockquote cite="https://www.youtube.com/watch?v=8onB7rPG4Pk">
							"The problem is to predict the price of an apartment in an up-and-coming neighborhood in NewYork City"
						</blockquote>
					</section>
					<section>
						<h5>Apartment Prices in NY</h5>
						<table>
							<thead><tr>
								<th>Price Per Square Foot</th>
								<th>Total Price?</th>
							</tr></thead>
							<tbody>
								<tr>
									<td>85</td>
									<td>$534.760</td>
								</tr>
								<tr>
									<td>67</td>
									<td>$535.717</td>
								</tr>
								<tr>
									<td>71</td>
									<td>$833.333</td>
								</tr>
								<tr>
									<td>18</td>
									<td>$728.377</td>
								</tr>
								<tr>
									<td>99</td>
									<td>$899.945</td>
								</tr>
								<tr>
									<td>69</td>
									<td>$760.564</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						Por un lado tenemos el precio por "pie cuadrado" de un departamento y por
						el otro tenemos el precio completo del mismo.
					</section>
					<section>
						Tiene que existir alguna correlación entre ambos y, en caso de existir,
						podemos crear un modelo predictivo que nos permita aprender cual es esa correlación
						para utilizarla en el futuro.
					</section>
					<section>
						<canvas class="stretch" data-chart="line">
							Apartment, 728.377, 535.717, 760.564, 833.333, 534.760, 899.945
							<!-- 
							{ 
								"data": {
									"labels": [18, 67, 69, 71, 85, 99],
									"datasets": [{ "borderColor": "#0ff", "borderDash": ["5","10"] }, { "borderColor": "#0ff" } ]
								}
							}
							-->
						</canvas>
					</section>
				</section>
				<section>
					<section>
						<h3>Regresión Lineal</h3>
						<h6>Ejemplo</h6>
					</section>
					<section>
						En este caso particular vamos a buscar la correlación lineal
						entre las notas obtenidas en un examen por alumno y horas de estudio.
					</section>
					<section>
						Uno puede pensar a priori que, cuanto más horas de estudio invierte una persona,
						mejores serán sus calificaciones.
					</section>
					<section>
						Pero vamos a demostrarlo matematicamente utilizando esta técnica simple de
						Machine Learning. Y para esto vamos a analizar el funcionamiento del método más popular de optimización,
						<h3 class="fragment fade-up">Gradient Descent</h3>
					</section>
					<section>
						<h4>Visualización</h4>
						<img src="images/gradient_descent_example.gif" alt="">
					</section>
					<section>
						Todo problema de Machine Learning se pienza en terminos de la <span class="fragment highlight-red">optimización</span>,
						en donde vamos a tener una <span class="fragment highlight-blue">función de pérdida</span> que queremos <span class="fragment highlight-red">minimizar</span>
						a travez del tiempo y, en este caso específico, utilizamos Gradient Descent
						como la técnica que nos va a permitir esto.
					</section>
					<section>
						Como ya se menciona anteriormente, la perdida será evaluada utilizando
						la función de error EMD.
					</section>
					<section>
						<img src="images/r_squared.png" alt="">
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Definición:</h3>
						\[
							Error_{(m, b)} = \frac{1}{N} \sum_{i=1}^{N} (y_i - (m x_i + b))^2
						\]
					</section>
					<section>
						<pre><code class="python hljs" data-trim contenteditable>
							def compute_error_for_line_given_points(b, m, points):
								"""
								y = mx + b
								m is slope, b is y-intercept
								"""
							
								totalError = 0
								
								for [x, y] in points:
									totalError += (y - (m * x + b)) ** 2
							
								return totalError / float(len(points))
						</code></pre>
					</section>
				</section>
				<section>
					<section data-background="images/tensor-flow.jpeg"></section>
					<section>
						<strong>TensorFlow</strong> es una biblioteca de software de código abierto para la programación 
						de flujo de datos en una variedad de tareas.
					</section>
					<section>
						Es una biblioteca matemática simbólica, y también se usa para aplicaciones de 
						aprendizaje automático como las redes neuronales. Se utiliza tanto para 
						investigación como para producción en Google.
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				transition: 'linear',

				chart: {
					defaults: { 
						global: { 
							title: { fontColor: "#FFF" }, 
							legend: {
								position: "top",
								labels: { fontColor: "#FFF" },
							},
							tooltips: {
								labels: { fontColor: "#FFF" },
							},
						},
						scale: { 
							scaleLabel: { fontColor: "#FFF" }, 
							gridLines: { color: "#FFF", zeroLineColor: "#FFF" }, 
							ticks: { fontColor: "#FFF" }, 
						} 
					},
					line: { 
						borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], 
						borderDash: [ [5,10], [0,0] ] 
					}, 
					bar: { 
						backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]
					},
					pie: { 
						backgroundColor: [ ["rgba(0,0,0,.8)" , "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"] ]
					},
					radar: { 
						borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]
					}, 
				},

				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'
				},

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{
						src: 'plugin/highlight/highlight.js',
						async: true,
						callback: function() {
							hljs.initHighlightingOnLoad();
						}
					},

					{ src: 'lib/js/classList.js' },
					{ src: 'plugin/math/math.js', async: true },

					{ src: 'plugin/chart/Chart.min.js' },				
					{ src: 'plugin/chart/csv2chart.js' },
				]
			});
		</script>
	</body>
</html>

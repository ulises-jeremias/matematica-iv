<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h4>Aplicaciones de la matemática en informática</h4>
					<p>Ejemplos del Mundo Real</p>
				</section>
				<section style="text-align: left; top: 193px; display: block;">
					<h4>Fundamentos detrás del Reconocimiento de Voz utilizando Machine Learning</h4>
				</section>
				<section>
					<section>
						<h3>Presentación</h3>
					</section>
					<section style="text-align: right; top: 193px; display: block;">
						Ulises Jeremias Cornejo Fandos
						<br>
						Licenciatura en Informática
						<br>
						4to Año
					</section>
					<section>
						<h3>Motivación</h3>
					</section>
				</section>
				<section>
					<section>
						<img src="images/pipeline.png" height="400px" style="border: none;" alt="">
					</section>
				</section>
				<section>
					Veamos primero cómo se analiza un audio.

					<p class="fragment">
						Para esto vamos a ver un concepto importante
						que nos va a permitir entender un poco más
						lo que significa un audio en términos de análisis de datos.
					</p>
				</section>
				<section>
					<section>
						<h3>Números Complejos</h3>
					</section>
					<section>
						<h4>Representación de objetos en un plano bidimensional</h4>
						<ul class="fragment">
							<li>
								Números complejos como herramientas
							</li>
							<li class="fragment">
								Casos específicos
							</li>
						</ul>
					</section>
					<section>
						<h4>Análisis de frecuencias</h4>
						<ul class="fragment">
							<li>
								Generación de terrenos
							</li>
							<li class="fragment">
								Análisis de sonido
							</li>
							<li class="fragment">
								...
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h3>Conceptos Necesarios</h3>
					</section>
					<section>
						<p>Un número complejo es un número de la forma $ a + bi $ donde:</p>
						<ul>
							<li class="fragment">
								<p>$ a, b \in \mathbb{R} $</p>
							</li>
							<li class="fragment">
								<p>$ i $ es la solución a la ecuación $ x^2 = -1 $</p>
							</li>
						</ul>
					</section>
					<section>
						<p>En el número $a + bi$, $a$ es la parte real y $b$ es la parte imaginaria.</p>
					</section>
					<section>
						<p>
							El sistema numérico complejo se puede definir como la extensión algebraica de los números reales
							ordinarios mediante un número imaginario $i$. Esto significa que los números complejos
							se pueden sumar, restar y multiplicar como polinomios en la variable $i$, con la regla
							$i^2 = -1$ impuesta.
						</p>
					</section>
					<section>
						<p>
							Además, los números complejos también se pueden dividir por números complejos
							distintos de cero.
						</p>
					</section>
					<section>
						<p>
							Geométricamente, los números complejos extienden el concepto
							de línea numérica unidimensional a <strong>plano complejo bidimensional</strong>.
						</p>
					</section>
					<section>
						<p>En el plano complejo, el número $a + bi$ puede representarse como el punto $(a, b)$ de la siguiente forma:</p>
						<a href="#" class="navigate-down">
							<img
								alt="Down arrow"
								data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png"
								style="border: none;"
								width="178"
								height="238"
							>
						</a>
					</section>
					<section>
						<h3>Plano Complejo</h3>
						<img src="images/complex_plane.jpg" alt="">
					</section>
				</section>
				<section>
					<section>
						<h2>Representación de objetos</h2>
						<h6>Traslaciones y Rotaciones</h6>
					</section>
					<section>
						<p>
							Los números complejos pueden sumarse y multiplicarse.
						</p>
					</section>
					<section>
						Geométricamente hablando, los números complejos se suman coordenada
						a coordenada. La multiplicación de dos números complejos
						se puede expresar más fácilmente en coordenadas polares:
					</section>
					<section>
						<p>Sean $a = x_1 + y_{1}i, b = x_2 + y_{2}i \in \mathbb{C}$ tales que:</p>

						<ul>
							<li>|$a$| $= r_a, arg(a) = \theta_a$</li>
							<li>|$b$| $= r_b, arg(b) = \theta_b$</li>
						</ul>

						<p>
							Definimos el producto complejo de la siguiente forma:
						</p>

						<p>
							\[\begin{aligned}
								ab &amp;= r_{a}r_{b} \textbf{e}^{i(\theta_a + \theta_b)} \\
									 &amp;= {r_{a}r_{b}}_{(\theta_a + \theta_b)}
							\end{aligned}\]
						</p>
					</section>
					<section>
						Luego, si $r_b = 1$ entonces la multiplicación funciona como rotación.
					</section>
				</section>
				<section>
					<section>
						<h2>Ejemplo Específico</h2>
					</section>
					<section>
						<p>
							Queremos representar la posición de un objeto cuyo
							movimiento se muestra de la siguiente forma:
						</p>

						<img width="500px" src="images/easy_harmonic_oscillator.gif" alt="">
					</section>
					<section>
						<p>
							Podemos ver como se comporta el movimiento en el eje x en la siguiente
							imagen:
						</p>

						<img src="images/complex_plane_sin.gif" alt="">
					</section>
					<section>
						<p>
							Además, observamos en el siguiente gráfico como es el
							comportamiento del mismo en función de funciones trigonométricas
							conocidas.
						</p>

						<img src="images/complex_plane_cos_sin.gif" alt="">
					</section>
					<section>
						A partir de la animación anterior podemos observar los siguientes
						items:
					</section>
					<section>
						En un caso ideal, la posición en el eje real se comporta como
						una función <em>coseno</em>.
					</section>
					<section>
						Pero, <strong>¿a qué llamamos caso ideal?</strong>
					</section>
					<section>
						El mundo físico no es ideal, y sabemos que la posición de un objeto
						cambia a medida que transcurre el tiempo.
					</section>
					<section>
						Necesitamos poder definir la posición del objeto en función del tiempo.
					</section>
					<section>
						<p>La misma se comporta de la siguiente forma:</p>
						<img width="526px" src="images/damped_oscillation.jpg" alt="">
					</section>
					<section>
						Para esto buscamos la forma de atenuar la función coseno que ya tenemos
						e indicar cuál será la amplitud inicial de la misma.
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Amplitud</h3>
						<p>
							Para definir la amplitud inicial de la función <em>coseno</em> simplemente
							multiplicamos la posición del objeto por un número que
							signifique la amplitud inicial del resorte, $A$.
						</p>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Periodo</h3>
						<p>
							Sabemos que la función $cos$ recibe la variable $t$ como argumento
							en cada iteración. Luego, podemos evaluar como afectaría
							a la posición del objeto multiplicar ese tiempo $t$ por
							un valor real $\omega$.
						</p>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Fase</h3>
						<p>
							Finalmente, determinamos cuán corrido está el dibujo de la función
							<em>coseno</em> en base a la fase $\phi$.
						</p>
					</section>
					<section>
						Se puede ver como los conceptos mencionados anteriormente
						afectan a la gráfica de una función $coseno$ y $seno$ en el siguiente
						<a href="https://www.geogebra.org/m/AUbsEpGa" target="_blank">
							enlace
						</a>.
					</section>
					<section>
						<p>
							Juntando todas las definiciones planteadas anteriormente,
							resumimos la posición del objeto en función del tiempo de la siguiente
							forma:
						</p>
						<ul>
							<li>$x(t) = Acos(\omega t + \phi)$</li>
							<li>$y(t) = Asin(\omega t + \phi)$</li>
						</ul>
					</section>
					<section>
						<p>
							Particularmente, si tomamos la amplitud $A$ como la distancia de la caja al centro del plano
							es decir, el módulo de la posición, y sea $\theta = \omega t + \phi$,
							el argumento de la posición a lo largo del tiempo, tenemos la
							posición en forma trigonométrica,
						</p>

						<p>
							\[
								r(t) = A (cos(\theta) + i sin(\theta))
							\]
						</p>
					</section>
				</section>
				<section>
					<section>
						<h3>Análisis de Frecuencias</h3>
					</section>
					<section>
						Respecto de este área de aplicaciones vamos a enfocarnos en dos
						casos de aplicación.
					</section>
					<section>
						El código de los ejemplos que se plantean a continuación se puede
						encontrar en el siguiente
						<a href="https://github.com/ulises-jeremias/frequency-analysis-with-FFT" target="_blank">
							repositorio
						</a>
						de github.
					</section>
					<section>
						En dicho repositorio se puede encontrar una breve descripción de cada uno
						de los proyectos, objetivos de los mismos y formas de utilización.
					</section>
				</section>
				<section>
					<section data-background="images/terrain-gen-view.jpeg" data-background-transition="zoom">
						<h3>Generación de Terrenos</h3>
					</section>
					<section>
						Como ejemplo tenemos la generación procedural de un terreno tridimensional
						utilizando <strong>Perlin Noise</strong> y la función
						<a href="https://processing.org/reference/beginShape_.html" target="_blank">
							<strong>
								beginShape
							</strong>
						</a>
						de Processing.
					</section>
				</section>
				<section>
					<section data-background="images/audio_analysis.jpg" data-background-transition="zoom">
						<h3>Análisis de audio</h3>
					</section>
					<section>
						En el repositorio de Análisis de Frecuencias se puede ver un proyecto
						en python, el cual permite observar cómo se representa gráficamente
						una onda de audio recibida por micrófono y se compara su gráfica
						con el espectro de la misma.
					</section>
					<section>
						Se utiliza <strong>scipy.fftpack</strong> para computar la <em>FFT</em>
						y mostrar el espectro del audio en tiempo real utilizando algunas
						herramientas del lenguaje <em>python</em>.
					</section>
					<section>
						<em>Análisis</em> se refiere a la acción de descomponer algo complejo en partes simples o 
						identificar en ese algo complejo las partes más simples que lo forman. Un proceso que cuantifique 
						las diversas intensidades de cada frecuencia se llama <strong>análisis espectral</strong>.
					</section>
					<section>
						Matemáticamente el análisis espectral está relacionado con una herramienta llamada 
						<strong>transformada de Fourier</strong> o <em>análisis de Fourier</em>.
					</section>
					<section>
						<p>
							Dada una señal o fenómeno ondultorio de amplitud $ s(t) $ esta se pude escribir matemáticamente 
							como la siguiente combinación lineal generalizada:
						</p>

						\[
							s(t) = \int_{\mathbf{R}} A(v)e^{-2 \pi ivt} d \omega
						\]
					</section>
					<section>
						Es decir, la señal puede ser concebida como la transformada de Fourier de la amplitud 
						$ A = A(v) $. Ese análisis puede llevarse a cabo para pequeños intervalos de tiempo, 
						o menos frecuentemente para intervalos largos.
					</section>
					<section>
						<img src="images/time-vs-frecuency-domain.jpg" alt="">
					</section>
					<section>
						Además veamos un curioso
						<a href="https://github.com/CFSworks/wavebird-reversing/blob/master/03_complex_signals_and_fourier/synthesize.py" target="_blank">
							ejemplo
						</a>
						de cómo se utilizan	señales complejas y la Transformada de Fourier para generar
						un archivo de audio a partir de una lista de números complejos
						representados en forma polar.
					</section>
				</section>
				<section>
					<section>
						<h3>Resumen</h3>
					</section>
					<section>
						Hasta ahora vimos como podemos utilizar los números complejos
						y el concepto de frecuencia para la generación de terrenos y
						el análisis de audio.
					</section>
					<section>
						Pero el análisis de frecuencias no se queda ahí.
					</section>
					<section>
						También podemos utilizar estos conceptos para...
					</section>
					<section data-background="images/meme.gif">
						<h2>Reconocimiento de voz</h2>
					</section>
				</section>
				<section>
					<section data-background="images/ml-view.png" data-background-transition="zoom">
						<h2>Machine Learning</h2>
					</section>
					<section>
						Subcampo de las ciencias de la computación y una rama de la inteligencia artificial, 
						cuyo objetivo es desarrollar técnicas que permitan que las computadoras aprendan.
					</section>
					<section>
						De forma más concreta, se trata de crear programas capaces de generalizar
						comportamientos a partir de una información suministrada en forma de ejemplos.
					</section>
					<section>
						El aprendizaje automático puede ser visto como un intento de automatizar
						algunas partes del método científico mediante métodos matemáticos.
					</section>
					<section>
						Es una de las ramas que, junto a la estadística, minería de datos y analítica predictíva, da lugar
						a la Ciencia de Datos.
					</section>
				</section>
				<section>
					<section>
						<h3>Matemática para Machine Learning</h3>
					</section>
					<section>
						Para ver como afectan las distintas ramas de la Matemática vamos
						a analizar el siguiente gráfico.
					</section>
					<section>
						<img src="images/diamond.png" alt="">
					</section>
					<section>
						En este gráfico se expone el núcleo de todo lo que da sentido al Machine Learning.
					</section>
					<section>
						<ul>
							<li>
								<strong>Estadística</strong> es el núcleo de todo esto.
							</li>
							<li class="fragment">
								<strong>Cálculo</strong> nos dice como aprende y se optimizan nuestros
								modelos.
							</li>
							<li class="fragment">
								<strong>Álgebra Lineal</strong> permite la ejecución de estos algoritmos
								en conjuntos de datos masivos.
							</li>
							<li class="fragment">
								<strong>Probabilidad</strong> ayuda a predecir la probabilidad de que un evento ocurra.
							</li>
						</ul>
					</section>
					<section>
						Para entender cómo entran en juego las ramas mencionadas anteriormente veamos
						un ejemplo simple a continuación.
					</section>
					<section>
						<h5><a href="https://www.youtube.com/watch?v=8onB7rPG4Pk" target="_blank" rel="noopener noreferrer">Ejemplo</a></h5>
						<blockquote cite="https://www.youtube.com/watch?v=8onB7rPG4Pk">
							"The problem is to predict the price of an apartment in an up-and-coming neighborhood in NewYork City"
						</blockquote>
					</section>
					<section>
						<h5>Apartment Prices in NY</h5>
						<table>
							<thead><tr>
								<th>Price Per Square Foot</th>
								<th>Total Price?</th>
							</tr></thead>
							<tbody>
								<tr>
									<td>85</td>
									<td>$534.760</td>
								</tr>
								<tr>
									<td>67</td>
									<td>$535.717</td>
								</tr>
								<tr>
									<td>71</td>
									<td>$833.333</td>
								</tr>
								<tr>
									<td>18</td>
									<td>$728.377</td>
								</tr>
								<tr>
									<td>99</td>
									<td>$899.945</td>
								</tr>
								<tr>
									<td>69</td>
									<td>$760.564</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						Por un lado tenemos el precio por "pie cuadrado" de un departamento y por
						el otro tenemos el precio completo del mismo.
					</section>
					<section>
						Tiene que existir alguna correlación entre ambos y, en caso de existir,
						podemos crear un modelo predictivo que nos permita aprender cuál es esa correlación
						para utilizarla en el futuro.
					</section>
					<section>
						<div>
							<canvas class="stretch" data-chart="line">
								Apartment, 728377, 437328, 403631, 535717, 760564, 833333, 914339, 534760, 899945, 480232
								<!-- 
								{ 
									"data": {
										"labels": [18, 54, 61, 67, 69, 71, 78, 85, 99, 100],
										"datasets": [{ "borderColor": "#0ff", "borderDash": ["5","10"] }, { "borderColor": "#0ff" } ]
									}
								}
								-->
							</canvas>
						</div>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Estadística</h3>
						Colección de técnicas que permiten extraer información valiosa de un conjunto de datos.
						Es una herramienta para crear un entendimiento a partir de un conjunto de números.
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h5>Inferencia Estadística</h5>
						Es el proceso de crear una predicción sobre una población de datos basándose en una muestra más
						pequeña a partir de la cual se pueda inferir ciertos parámetros significativos para la predicción.
					</section>
					<section>
						Teniendo en cuenta que queremos hallar una línea, nosotros vamos a utilizar
						una herramienta estadística llamada,
						<h3 class="fragment fade-up">Regresión Lineal</h3>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Regresión Lineal</h3>
						Nos permite resumir la relación entre dos variables, una dependiente y otra independiente.
					</section>
					<section>
						<img src="images/line.png" alt="">
					</section>
					<section>
						Nosotros sabemos que existen valores ideales para $m$ y $b$
						y son aquellos en los que, al utilizar esos valores,
						significan el mejor ajuste para nuestro conjunto de datos.
					</section>
					<section>
						Es por esto que necesitamos una herramienta que nos permite
						conocer el error de nuestra predicción. Necesitamos una función
						de error la cual podamos optimizar para que sea mínima, e.g.,
						<h3 class="fragment fade-up">Error Cuadrático Medio</h3>
					</section>
					<section>
						<img src="images/r_squared.png" alt="">
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Definición</h3>
						\[
							ECM = \frac{1}{N} \sum_{i=1}^{N} (Y - \hat{Y})^2
						\]
					</section>
					<section>
						<p>Y ahora que tenemos los datos, y sabemos como calcular el error de nuestra
							predicción, podemos construir un gráfico de la siguiente forma:</p>

						<a href="#" class="navigate-down">
							<img
								alt="Down arrow"
								data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png"
								style="border: none;"
								width="178"
								height="238"
							>
						</a>
					</section>
					<section>
						<img height="500px" src="images/3d_plot.png" alt="">
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Cálculo</h3>
						Disciplina matemática que permite el estudio del cambio, y del cual sale un algoritmo de optimización
						que utilizaremos para resolver este problema, <span class="fragment highlight-blue">Gradient Descent</span>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Gradient Descent</h3>
						Algoritmo de optimización iterativo de primer orden para encontrar el mínimo 
						de una función.
						<h5 class="fragment fade-up">¡¡No confundir con Method of Steepest Descent!!</h5>
						<img class="fragment" style="float: right; margin-top: -55px; margin-right: 155px; border: none;" src="images/mucho-muy-importante.png" width="520px" alt="">
					</section>
					<section>
						Para encontrar el mínimo local de una función que utiliza el descenso de gradiente, 
						se toman pasos proporcionales al negativo del gradiente (o gradiente aproximado) 
						de la función en el punto actual.
					</section>
					<section>
						Si, en cambio, uno toma pasos proporcionales al 
						positivo del gradiente, uno se acerca al máximo local de esa función; 
						el procedimiento se conoce como ascenso de gradiente.
					</section>
					<section>
						<h3>Ejemplo</h3>
						<h6>Lo veremos en breve</h6>
					</section>
					<section>
						Pero, que pasaría si no buscamos la correlación entre dos variables,
						sino que además queremos saber la relación con la cantidad de baños,
						habitaciones, etc.
					</section>
					<section>
						<h3>Multivariate Regression</h3>

						\[
							Y_t = a_1 + b_2 X_{2t} + ... + b_{(n+1)} X_{(n+1)t} + e_t
						\]
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Algebra Lineal</h3>
						Es la rama de la matemática que estudia espacios multivariados,
						las transformaciones lineales existentes entre ellos y cómo
						pueden representarse estas cuestiones en términos de matrices y espacios vectoriales.
					</section>
					<section>
						<h5>Pero, dónde entra Probabilidad en todo esto?</h5>

						<h3 class="fragment fade-up">Logistic Regression</h3>
					</section>
				</section>
				<section>
					<section>
						<h3>Regresión Lineal</h3>
						<h6>Ejemplo</h6>
					</section>
					<section>
						En este caso particular vamos a buscar la correlación lineal
						entre las notas obtenidas en un examen por alumno y horas de estudio.
					</section>
					<section>
						Uno puede pensar a priori que, cuanto más horas de estudio invierte una persona,
						mejores serán sus calificaciones.
					</section>
					<section>
						Pero vamos a demostrarlo matematicamente utilizando una técnica simple de
						Machine Learning. Y para esto vamos a analizar el funcionamiento del método más popular de optimización,
						<h3 class="fragment fade-up">Gradient Descent</h3>
					</section>
					<section>
						<h4>Visualización</h4>
						<img src="images/gradient_descent_example.gif" alt="">
					</section>
					<section>
						Todo problema de Machine Learning se piensa en términos de la <span class="fragment highlight-red">optimización</span>,
						en donde vamos a tener una <span class="fragment highlight-blue">función de pérdida</span> que queremos <span class="fragment highlight-red">minimizar</span>
						a través del tiempo y, en este caso específico, utilizamos Gradient Descent
						como la técnica que nos va a permitir esto.
					</section>
					<section>
						Como ya se menciona anteriormente, la pérdida será evaluada utilizando
						la función de Error Cuadrático Medio.
					</section>
					<section>
						<img src="images/r_squared.png" alt="">
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Definición:</h3>
						\[
							Error_{(m, b)} = \frac{1}{N} \sum_{i=1}^{N} (y_i - (m x_i + b))^2
						\]
					</section>
					<section>
						<pre><code class="python hljs" data-trim contenteditable>
							def compute_error(b, m, points):
								"""
								y = mx + b
								m is slope, b is y-intercept
								"""
							
								totalError = 0
								
								for [x, y] in points:
									totalError += (y - (m * x + b)) ** 2
							
								return totalError / float(len(points))
						</code></pre>
					</section>
					<section>
						Luego, dada la función descripta anteriormente, necesitamos evaluar algún
						método que nos permita optimizar el error de forma que sea el mínimo.
					</section>
					<section>
						Para esto evaluamos las derivadas parciales, respecto de $m$ y $b$,
						para realizar el descenso de gradiente.
					</section>
					<section data-background-transition="zoom" data-background="#4d7e65">
						\[
							\frac{\partial}{\partial m} = \frac{2}{N} \sum_{i=1}^{N} -x_i (y_i - (m x_i + b))
						\]

						<br>

						\[
							\frac{\partial}{\partial b} = \frac{2}{N} \sum_{i=1}^{N} -(y_i - (m x_i + b))
						\]
					</section>
					<section>
						<pre><code style="margin-left: -7.5%; width: 115%;" class="python hljs" data-trim contenteditable>
							def gradient_descent(points, b, m, learning_rate, num_iterations):
								for _ in range(0, num_iterations):
									[b, m] = step_gradient(b, m, array(points), learning_rate)
								
								return [b, m]
						</code></pre>
					</section>
					<section>
						<pre><code class="python hljs" data-trim contenteditable>
							def step_gradient(b, m, points, learning_rate):
								b_gradient = 0
								m_gradient = 0
								N = float(len(points))

								for [x, y] in points:
									b_gradient += y - ((m * x) + b)
									m_gradient += x * (y - ((m * x) + b))

								new_b = b - (learning_rate * (-2/N) * b_gradient)
								new_m = m - (learning_rate * (-2/N) * m_gradient)

								return [new_b, new_m]
						</code></pre>
					</section>
					<section>
						<h3>Ver Ejemplo</h3>
					</section>
				</section>

				<section>
					<section data-background="images/tensor-flow.jpeg"></section>
					<section>
						<strong>TensorFlow</strong> es una biblioteca de software de código abierto para la programación 
						de flujo de datos en una variedad de tareas.
					</section>
					<section>
						Es una biblioteca matemática simbólica, y también se usa para aplicaciones de 
						aprendizaje automático como las redes neuronales. Se utiliza tanto para 
						investigación como para producción en Google.
					</section>
					<section>
						<h3>Ver Ejemplo</h3>
					</section>
				</section>

				<section>
					<section>
						<h3>Resumen</h3>
					</section>
					<section>
						<h5>Qué tenemos hasta ahora?</h5>
						<ul>
							<li>
								Entendemos qué es un audio en términos de información.
							</li>
							<li class="fragment">
								Tenemos herramientas que nos permiten realizar un análisis del audio y extraer información interesante.
							</li>
							<li class="fragment">
								Conocemos cómo aprende una máquina en términos de optimización.
							</li>
							<li class="fragment">
								Sabemos cómo suministrarle información a un modelo para permitirle aprender.
							</li>
						</ul>
					</section>
					<section>
						<h3>Y ahora qué?</h3>
					</section>
					<section>
						<img src="images/hello.png" style="border: none;" alt="">
					</section>
				</section>

				<section data-background-transition="zoom" data-background="images/nn-view.jpeg">
					<h3>Redes Neuronales</h3>
				</section>
				<section>
					<section>
						<h4>¿Cómo funciona el cerebro?</h4>
						<img src="images/b_neuron.png" alt="">
					</section>
					<section>
						<h4>¿Cómo funciona el cerebro?</h4>
						<ul>
							<li>
								<strong>Neurona:</strong> Unidad computacional básica a nivel cerebral
								<ul>
									<li class="fragment">86.000 millones de neuronas</li>
								</ul>
							</li>
							<li class="fragment">Conectadas a través de <strong>sinapsis</strong>: \[ 10^{14} – 10^{15} \]</li>
							<li class="fragment">Reciben señales de entrada desde las <strong>dendritas</strong></li>
							<li class="fragment">Producen señales de salida a través del <strong>axón</strong>
								<ul>
									<li class="fragment">Interactúa con dendritas de otras neuronas a través de <strong>pesos sinápticos</strong></li>
									<li class="fragment"><strong>Aprendizaje</strong>: Adaptación de pesos</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<img src="images/dog.jpg" style="border: none;" alt="">
					</section>
					<section>
						<h3>Redes Neuronales Artificiales</h3>
						<img src="images/neuron.png" alt="">
					</section>
					<section>
						<h3>Conjuntos de sumas con pesos</h3>
						<img src="images/network.png" alt="">
					</section>
					<section>
						<p>Cada <strong>sinapsis</strong> posee un <strong>peso</strong> utilizado para la <strong>activación</strong> de la neurona.</p>
						<img src="images/dnn.png" alt="">
					</section>
					<section>
						<p>Partiendo de este concepto básico aparecen distintos tipos de NN.</p>
						<ul>
							<li class="fragment">Redes Neuronales Profundas - DNN</li>
							<li class="fragment">Redes Neuronales de Convolución - CNN</li>
							<li class="fragment">etc</li>
						</ul>
					</section>
					<section>
						<h4>Redes Neuronales Profundas</h4>
						<p>Deep Learning</p>
					</section>
					<section>
						<h3>Redes Neuronales LSTM</h3>
						<p>Redes Neuronales Recurrentes</p>
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Redes Neuronales Recurrentes</h3>

						Una <strong>red neuronal recurrente</strong>,  <em>RNN</em>, es una clase de red neuronal artificial 
						donde las conexiones entre los nodos forman un gráfico dirigido a lo largo de una secuencia. 
						Esto le permite exhibir un comportamiento dinámico temporal para una secuencia de tiempo. 
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						A diferencia de las redes neuronales de alimentación directa, los RNN pueden usar su estado 
						interno <em>(memoria)</em> para procesar secuencias de entradas. Esto los hace aplicables 
						a tareas como el reconocimiento de escritura manuscrita no segmentada o el <strong>reconocimiento de voz</strong>.
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						<h3>Long short-term memory</h3>

						Las unidades de <strong>memoria a largo plazo</strong>, <em>(LSTM)</em>, son unidades de una RNN. Un RNN compuesto de unidades 
						LSTM a menudo se llama una <strong>red LSTM</strong>.
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						Una unidad LSTM común se compone de una celda, una puerta de entrada, 
						una puerta de salida y una puerta olvidada. La celda recuerda valores en intervalos de tiempo arbitrarios 
						y las tres puertas regulan el flujo de información que entra y sale de la celda.
					</section>
					<section style="text-align: left; top: 193px; display: block;">
						Las redes LSTM están bien adaptadas para clasificar, procesar y hacer predicciones <span class="fragment highlight-red">basadas en datos de series de tiempo</span>, 
						ya que puede haber retrasos de duración desconocida entre eventos importantes en una serie de tiempo. Los LSTM se desarrollaron 
						para hacer frente a los problemas de gradiente de explosión y desaparición que se pueden encontrar al entrenar RNN tradicionales.
					</section>

					<section>
						<pre><code class="python hljs" style="margin-left: -7.5%; width: 115%;" data-trim contenteditable>
							import tensorflow as tf
							import tflearn
							
							import speech_data
							
							learning_rate = 0.0001
							training_iters = 300000 # steps
							batch_size = 64
							
							width = 20  # mfcc features
							height = 80  # (max) length of utterance
							classes = 10  # digits
							
							batch = word_batch = speech_data.mfcc_batch_generator(batch_size)
							
							# Network building
							net = tflearn.input_data([None, width, height])
							net = tflearn.lstm(net, 128*4, dropout=0.5)
							net = tflearn.fully_connected(net, classes, activation='softmax')
							net = tflearn.regression(net, 
										 optimizer='adam', 
										 learning_rate=learning_rate, 
										 loss='categorical_crossentropy')

							model = tflearn.DNN(net, tensorboard_verbose=0)
							
							## add this "fix" for tensorflow version errors
							for x in tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES): 
								tf.add_to_collection(tf.GraphKeys.VARIABLES, x )
							
							# Training
							
							while --training_iters > 0:
								trainX, trainY = next(batch)
								testX, testY = next(batch)  # todo: proper ;)
								model.fit(trainX, trainY, 
									  n_epoch=10, 
									  validation_set=(testX, testY), 
									  show_metric=True, 
									  batch_size=batch_size)
							
							model.save("tflearn.lstm.model")
							_y = model.predict(next(batch)[0])  # << add your own voice here
							print (_y)
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Links de interes</h2>
						<ul>
							<li>
								<a href="https://github.com/ulises-jeremias/matematica-iv" target="_blank">
									Repositorio de la charla
								</a>
							</li>
							<li>
								<a href="https://github.com/ulises-jeremias/frequency-analysis-with-FFT" target="_blank">
									Frecuency Analysis with FFT
								</a>
							</li>
							<li>
								<a href="https://github.com/CFSworks/wavebird-reversing" target="_blank">
									Reverse-engineering Nintendo's WaveBird wireless controller
								</a>
							</li>
							<li>
								<a href="https://github.com/pannous/tensorflow-speech-recognition" target="_blank">
									Speech Recognition with TensorFlow
								</a>
							</li>
						</ul>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				transition: 'linear',

				chart: {
					defaults: { 
						global: { 
							title: { fontColor: "#FFF" }, 
							legend: {
								position: "bottom",
								labels: { fontColor: "#FFF" },
							},
							tooltips: {
								labels: { fontColor: "#FFF" },
							},
						},
						scale: { 
							scaleLabel: { fontColor: "#FFF" }, 
							gridLines: { color: "#FFF", zeroLineColor: "#FFF" }, 
							ticks: { fontColor: "#FFF" }, 
						} 
					},
					line: { 
						borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], 
						borderDash: [ [5,10], [0,0] ] 
					}, 
					bar: { 
						backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]
					},
					pie: { 
						backgroundColor: [ ["rgba(0,0,0,.8)" , "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"] ]
					},
					radar: { 
						borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]
					}, 
				},

				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'
				},

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{
						src: 'plugin/highlight/highlight.js',
						async: true,
						callback: function() {
							hljs.initHighlightingOnLoad();
						}
					},

					{ src: 'lib/js/classList.js' },
					{ src: 'plugin/math/math.js', async: true },

					{ src: 'plugin/chart/Chart.min.js' },				
					{ src: 'plugin/chart/csv2chart.js' },
				]
			});
		</script>
	</body>
</html>
